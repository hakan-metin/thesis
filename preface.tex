\clearpage\null\vfill
\thispagestyle{empty}
\begin{minipage}[b]{.9\textwidth}
  \begin{center}
  \setlength{\parskip}{.5\baselineskip}
  {\color{phdcol0}%
   \ccLogo\hspace{.1cm}%
   \ccAttribution\hspace{.1cm}%
   \ccNonCommercial\hspace{.1cm}%
   \ccNoDerivatives}\hspace{.15cm}%
  \footnotesize%
  This work is licensed under {\color{phdcol1}\textbf{http://creativecommons.org/licenses/by-nc-nd/3.0/}}
  \end{center}
\end{minipage}
\vspace*{2\baselineskip}

\clearpage

\thispagestyle{empty}
\vspace*{\stretch{1}}
\begin{flushright}
  \textit{Ah, la thèse.}
\end{flushright}
\vspace*{\stretch{7}}
%
%%
%\chapter*{Remerciements}
%
%
%\`A tous, \textbf{merci infiniment} !

%
\chapter*{Résumé Long en Français}

Cette thèse traite la résolution du problème de satisfaisabilité booléenne (SAT)
qui peut être définit de la façon suivante,
étant donné une formule propositionnelle (généralement les contraintes d'un problème codé),
La résolution de SAT consiste à décider si la formule est satisfaisante (toutes les contraintes peuvent être
satisfaites) ou insatisfaisante (il n'y a aucun moyen de satisfaire toutes les contraintes en même
temps). Ce calcul est effectué par un solveur SAT qui répond usuellement $\sat$ lorsque la formule est satisfaisante et $\unsat$ sinon.
 
Le problème SAT a été le premier problème à avoir été prouvé NP-Complet. Cela signifie que
l'on ne connaît pas d'algorithme capable le résoudre avec une complexité polynomiale.
Si un tel algorithme existe, cela résoudrai l'un des sept problèmes du prix du millénaire, à savoir 
P vs NP.

Malgré cette complexité, les solveurs SAT deviennent de plus en plus efficace.
Au cours des dernières décennies, ceux-ci peuvent traiter des problèmes de plus en plus complexes dans différents domaines: comme les méthodes formelles telles que: la vérification du modèle borné (BMC)\cite{bmc_99} ; l'intelligence artificielle : décision de planification~\cite{planning_92} ; l'informatique : inférence haplotype~\cite{biology_06}. 
Dans un travail récent, des chercheurs ont réussi a prouver à l'aide d'un solveur SAT, une borne maximum
pour le problème de coloration des triplets Pythagoriciens~\cite{heule2016solving}, avec une preuve pesant 200 TB.

Ce succès vient de l'introduction d'heuristiques sophistiquées et de l'optimisation de l'algorithme de
résolution des conflits appelé $\guillemotleft$ Conflict Driven Clause Learning$\guillemotright$ (CDCL). Il est basé sur le premier
algorithme (avec une utilisation non intensif en mémoire) nommé par ses auteurs Davis, Putnam, Logemann
et Loveland (DPLL)\cite{dpll_62}.


Cette algorithme peut être vu sous forme de l'exploration d'un arbre ou chaque branche représente 
une affectation. Il y a donc au total $2^n$ branches, avec $n$ le nombre de variables du problèmes.
Le principe de cet algorithme est d'explorer cet arbre binaire. 
La première étape consiste à choisir une variable dite de décision avec une polarité qui permet l'exploration
de l'arbre de recherche. Ensuite, les déductions logiques à partir de l'affection courantes sont effectuées. 
Si l'algorithme découvre un conflit, c'est à dire que l'affectation courante n'est pas capable de satisfaire au moins une contrainte du problème, l'algorithme va calculé une clause dite de conflit qui permet d'élaguer 
cet espace de recherche qui ne contient pas de solution. Cette clause est une information redondante par
rapport au problème initial. Si aucun conflit n'est présent, l'algorithme choisit à nouveau une variable de décision. L'algorithme termine lorsque soit toutes les variables sont affecté au quel cas le problème 
est satisfait, soit un conflit est apparu avec uniquement des diductions logiques au quel cas le
problème est non satisfaisant.
La Figure~\ref{fig:cdclflow} présente sous forme d'un organigramme le fonctionnement de l'algorithme CDCL.

\input{fig/flowcdcl}


Cependant certains problème présente des symétries, certaines branches de l'espace de recherche 
sont donc équivalentes à la symétrie près. Prenons comme exemple le $\guillemotleft$problème des pigeons $\guillemotright$ dans lequel nous avons un ensemble de pigeons qui doivent êtres attribués à des nids différents. Dans ce problème il y a un nids de moins que le nombre de pigeons.
Le but de ce problème est de déterminer si il est possible d'attribuer un nid différent à chaque pigeon.
 La figure ... pressente un instance de ce problème.
 
Pour un humain, la réponse à ce problème est évidente, un solveur de l'état de l'art va parcourir toutes 
les combinaisons possibles (pigeon, nid), cela qui mène a une explosion combinatoire.
Résoudre ce problème avec un solveur s'avère très chronophage et même impossible dans des temps raisonnable
pour un nombre de pigeons supérieur a 15.

%Cependant, certains problèmes possèdent un espace de recherche énorme et ne peuvent pas 
%être traité par un solveur SAT. Un exemple d'un tel problème peut être le problème de tournées de véhicules (VRP). 
%Il s'agit du service d'entreprise de livraison, dans lequel étant donné une flotte de véhicules basés dans un dépôt, ceux ci doivent faire des rondes entre des clients qui ont demandés chacun une certaine quantité de marchandises. Le circuit effectué par un véhicule pour la visite de tous les clients
%est appelé la tournée du véhicule. L'objectif est de trouver la tournée qui minimise les coûts de livraison (monétaire, distance, temps, ....).
%
%
%Dans le problème précédent, renommer l'ensemble de véhicules identiques nous donnera exactement le même problème. C'est ce qu'on appelle une symétrie. 

De manière plus  général, une symétrie est une transformation qui laisse un objet (ou un aspect de l'objet) inchangé. Les symétries sont généralement définie comme une propriété syntaxique d'un problème lorsque leur présence est inhérente à l'encodage du problème.
Dans ce cas, une permutation des variables préservent la spécification originale du problème.
Dans le cas où les symétries sont indépendantes d'une représentation particulière du problème, il s'agit de symétries sémantiques.

La présence de symétrie dans un problème force l'algorithme de recherche à explorer en vain l'espace de recherche symétrique et entrave considérablement ses performances. La rupture de symétrie est une approche qui évite au solveur de visiter l'espace de recherche symétrique.

Pour pouvoir exploiter les symétries, la première étape consiste à les trouver. Dans le contexte de la satisfaction booléenne, la détection des symétries syntaxique se fait par tout d'abord par la transformation de la spécification en un graphe coloré et ensuite à l'application d'un outil d'automorphisme de graphe.
Différent outils qui traitent ce problème existe dans l'état de l'art tel que $\bliss$~\cite{JunttilaKaski:ALENEX2007}, $\saucy$~\cite{katebi2010symmetry}, ...


Lorsque les symétries sont obtenues à l'aide de ces outils, l'approche la plus courante pour les exploiter est d'utiliser une technique de rupture de symétrie statique. Celui ci consiste à prendre le problème symétrique en entrée et à produire une formule équivalente en éliminant les symétries présentes dans le problème.
Cette technique est dite statique car elle est effectué avant la résolution du problème SAT. 

Pour produire une formule équivalente sans présence de symétries, le problème est augmenté par des 
contraintes de rupture de  symétries (e $\guillemotleft$symmetry breaking predicates $\guillemotright$ sbp). Celles ci empêchent le solveur d'explorer l'espace de recherche symétrique. 
Autrement dit, si l'on considère notre exemple précédent avec les pigeons, le premier pigeon est attribué a un
exactement un nid, la symétrie est alors "cassé".
Plusieurs outils tels que $\shatter$~\cite{} et $\breakid$~\cite{} utilisent cette technique pour accélérer le solveur en présence de symétries.
En général, cette approche a de bon résultats dans plusieurs instances symétrique mais possède des défauts.
Le nombre de contraintes ajoutées peut être exponentielle par rapport à la taille du problème, ce qui a
pour conséquence de ralentir l'algorithme principal du solveur. De plus, étant donné que ce calcul est effectué
avant le lancement du calcul du solveur, celui-ci ne peut pas différentier les contraintes originales du problème
et les contraintes de rupture de symétrie. Avec cette information, le solveur peut modifier ces heuristiques, ce 
qui peut augmenter ces performances.
Certains problèmes avec de nombreuses symétries ne peuvent pas être traités avec cette technique.

Une autre approche consiste à utiliser les symétries pendent l'algorithme du solveur SAT, plus précisément à modifier son comportement en utilisant les symétries.
Cette approche est dite dynamique.
Les faits symétriques sont déduit à partir des déductions que le solveur a construit. 
Avec l'absence du module de symétrie, tous les 
faits devront être explorer en vain. Ces faits symétrique vont augmenter les performances du solveur.
Différent outils tel que \textit{Symmchaff}, \textit{Symmetry Propagation (SP)}, \textit{Symmetry Learning Scheme (SLS)} utilisent l'approche de rupture de symétrie dynamique.


Cette thèse vise à améliorer l'existant et rendre les solveurs plus performants en présence de symétries et
propose différente contributions allant dans ce sens.  

\subsection{Première Contribution}

Notre première contribution consiste à mimer le comportement de la rupture de symétrie statique mais 
opère dynamiquement, pendant l'exécution du solveur. On ajoute dans le solveur un composant de symétrie opportuniste qui va détecter que le solveur parcours un espace de recherche symétrique et va ajouter
une contrainte appelé $\guillemotleft$ effectective symmetry breaking predicate $\guillemotright$ qui va empêcher le solveur de rester dans
l'espace de recherche symétrique. Cette contrainte est dite effective car à l'inverse de l'approche 
de rupture de symétrie  statique la contraintes est forcément utilisé par le solveur. Aucune contrainte
inutile est inséré dans le solveur. Cela a pour conséquence de réduire le nombre de contrainte et donc 
ne ralentit pas les solveur.

Ce composant de symétrie est fournit sous forme d'une bibliothèque codé en C++ et se nomme $\libdsb$.
Elle peut s'interfacer avec n'importe quelle solveur de type CDCL. 
Nous l'avons interfacé avec un solveur de l'état de l'art nommé $\minisat$~\cite{een2003extensible}. Au total, l' intégration de $\libdsb$ ajoute environ 60 lignes de code 
et augmente de code de $\minisat$ de 3\%.
$\libdsb$ est open source fournit sous la licence GPLv3 et est disponible sur Github à l'adresse \url{https://github.com/lip6/cosy}.


Nous avons comparés les performances de notre approche avec le solveur $\minisat$
Les nombreuses expérimentations effectuées sur les instances symétrique de la SAT Competiton~\cite{jarvisalo2012international} sur les six dernière année nous démontre que notre approche est aussi performante que les approches de ruptures de symétries statiques.


\chapter*{Abstract}

This is an abstract.