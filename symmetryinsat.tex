\chapter{Symmetry and SAT}\label{chap:symmetryinsat}
\minitoc

Despite SAT solving is an NP-complete algorithm, it works well on many real industrial problems. This is 
principally due to capacity to cut off search space with learning clause. Another way to cut off search space is the exploitation of symmetry.
At its most basics, symmetry is a transformation of an object that leaves it unchanged. 
Symmetries is common in real life, if we take some butterfly, it has exactly the same halves.
If we search a pattern on one halve and not found it, searching the same pattern in the other halve is 
completely absurd. But some of them are not symmetric and we must check pattern in every halves.

In this chapter, we show how to detect if the given formula presents symmetries and if it is the case, how to
exploit them and so accelerate the solving time.


%Some instances exhibit symmetries and not taking them into account forces solvers to needlessly explore isomorphic search space.  










\section{Group basics}
As symmetries is a belongs to a branch of mathematics called theory group.
This section gives us an overview of group theory.

\subsection{Groups}
A \emph{group} is a structure $\langle G, * \rangle$, where $G$ is a non-empty set and $*$ a binary
operation such as the following axioms are satisfied:
\begin{itemize}[noitemsep,nolistsep]
 \item \emph{associativity}: $\forall a, b, c \in G, (a * b) * c = a * (b * c)$
 \item \emph{closure}: $\forall a, b \in G, a * b \in G$.
 \item \emph{identity}: $\forall a \in G, \exists e$ such that $ a * e = e * a = a$
 \item \emph{inverse}:  $\forall a \in G, \exists b \in G$, commonly denoted $a^{-1}$ such that
 $a * a^{-1} = a^{-1} * a = e$
\end{itemize}
Note that \emph{commutativity} is not required i.e $\ a * b = b * a$, for $a, b \in G$.
A group is \emph{abelian} if it satisfies the commutativity rule.
Moreover, the last definition leads to important properties which are: i) uniqueness of the identity element. 
To prove this property, assume $\langle G, * \rangle$ a group with two identity elements $e$ and $f$ 
then $ e = e * f = f$.
ii) uniqueness of the inverse element. To prove this property, suppose that an element $x_1$ has two inverses,
denoted $b$ and $c$ in groups $\langle G, * \rangle$, then\\

 $\begin{array}{lcll}     
b & = & b * e & \\
& = & b * (a * c) & c \text{ is an inverse of } a, \text{so } e = a * c\\
& = & (b * a) * c &   \text{\emph{associativity} rule}\\
& = & e * c       & b \text{ is an inverse of } a, \text{so } e = a * b\\
& = & c           &   \text{\emph{identity} rule}
\end{array}$

The structure $\langle G, * \rangle$ is denoted as G when clear from context that G is a group
with a binary operation. In this thesis, we are interested only with the \emph{finite} groups i.e
with a finite number of elements.
Given a group $G$, a \emph{subgroup} is a non-empty subset of $G$ which is also a group with 
the same binary operation. If $H$ is a subgroup of $G$, we denote as $H \leq G$.
A group has at least two subgroups: i) the subgroup composed by the identity element $\{e\}$, denoted \emph{trivial} subgroup.
All other subgroups are \emph{nontrivial}; ii) the subgroup composed by itself,
denoted \emph{improper} subgroup. All other subgroups are \emph{proper}.

\subsubsection{Generators of a group}
If every element in a group G can be expressed as a linear combination
of a set of a group of elements S = $\{g_1, g_2, ..., g_n \}$ then we say G is 
generated by the S. we denote this as G = $\langle S \rangle$ =
$\langle \{g_1, g_2, ..., g_n \} \rangle$ 

\subsection{Permutation groups}
A \emph{permutation} is a bijection from a set $X$ to itself.\\
Example: given a set $X = \{x_1, x_2, x_3, x_4, x_5, x_6\}$,
\begin{center}
$g = ${\Bigg( \begin{tabular}{cccccc}
  $x_1$ & $x_2$ & $x_3$ & $x_4$ & $x_5$ & $x_6$\\
  $x_2$ & $x_3$ & $x_1$ & $x_4$ & $x_6$ & $x_5$
 \end{tabular} \Bigg)}\\
\end{center}
$g$ is a permutation that maps $x_1$ to $x_2$, $x_2$ to $x_3$, $x_3$ to $x_1$, $x_4$ to $x_4$, $x_5$ to $x_6$ and $x_6$ to $x_5$.
Permutations are generally written in \emph{cycle notation}, the self-mapped elements are omitted.
So the permutation in cycle notation will be 
\begin{center}
 $g$ = ($x_1 \enskip x_2 \enskip x_3$) ($x_5 \enskip x_6$)
\end{center}
We say \emph{support} of the permutation $g$ noted $\support_{g}$ the elements that not mapped to themselves:
\begin{center}
 $\support_{g} = \{ x \in X \mid g.x \neq x\}$
\end{center}
A variable $x$ is \emph{stable} by a permutation $g$ 
if $x \notin \support_g$. A clause $\omega$ is \emph{stabilized} by a permutation $g$ if 
$\omega \cap \support_g = \emptyset$.

A set of permutations of a given set $X$ form a group $G$,
with the composition operation ($\circ$) and is called \emph{permutation group}.
The \emph{symmetric group} is the set of all possible permutations of a set $X$ and noted \Group($X$).
%The set of \textbf{all} permutations of a set $X$ is the \emph{symmetric group} of $X$ and noted \Group($X$).
So, a \emph{permutation group} is a subgroup of \Group($X$). 
%A set of permutations $P$ is a set of \emph{generators} of a group $G$ if each permutation of $G$
%can be expressed as a composition of permutations in $P$. 

A permutation group $G$ induces an \emph{equivalence relation} on the set of elements $X$ being
permuted. Two elements $x_1, x_2 \in X$ are equivalent if there exists a permutation $g \in G$ such that
$g.x_1 = x_2$. The equivalence relation partition $X$ into \emph{equivalence classes} referred to
as the \emph{orbits} of $X$ under $G$. The orbit of an element $x$ under group $G$ (or simply orbit of $x$ when clear
from the context) is the set. $[x]_G = \{g.x \mid g \in G\}$

\section{Symmetries in SAT}
The previous mathematical definition of group theory is applied to the CNF formula.
The symmetric group of permutations of $\Vars$ (i.e. bijections from $\Vars$ to $\Vars$) is noted
$\Group(\Vars)$. The group $\Group(\Vars)$ naturally acts on the set of literals: for $g
\in \Group(\Vars)$ and a literal $\ell \in \Lits $, $g.\ell = g(\ell)$ if $\ell$ it is a
positive literal, $g.\ell = \neg g(\neg \ell)$ if $\ell$ is a negative literal.
The group $\Group(\Vars)$ also acts on  assignments possibly partial of $\Vars$ as follows: 
\begin{center}
 $\forall g \in \Group(\Vars)$, $\alpha \in \Assignments(\Vars)$, $g.\alpha = \{ g.\ell ~|~ \ell \in \alpha \}$.
\end{center}
 We say that $g\in \Group(\Vars)$ is a symmetry of $ \varphi$ if following conditions holds:
\begin{itemize}[topsep=0em]
 \item permutation fixes the formula, $g.\varphi =  \varphi$ 
 \item $g$  commutes with the negation: $g.\neg l  = \neg g.l$
\end{itemize}
The set of symmetries of $\varphi$ is noted $G_(\varphi)$ and is a subgroup of $\Group(\Vars)$.
Symmetries of a formula $\varphi$ preserves the satisfaction, for every \emph{complete} assignment $\alpha$:
\begin{center}
 $\alpha \models \varphi\Leftrightarrow g.\alpha \models \varphi$
\end{center}
%$
%\neg x_1 \neg x_2 \\
%\neg x_1 \neg x_3 \\
%\neg x_2 \neg x_3 \\
%\neg x_4 \neg x_5 \\
%\neg x_4 \neg x_6 \\
%\neg x_5 \neg x_6 \\
%\neg x_7 \neg x_8 \\
%\neg x_7 \neg x_9 \\
%\neg x_8 \neg x_9 \\
%\neg x_{10} \neg x_{11} \\
%\neg x_{10} \neg x_{12} \\
%\neg x_{11} \neg x_{12} \\
%x_1 x_4 x_7 x_{10} \\
%x_2 x_5 x_8 x_{11} \\
%x_3 x_6 x_9 x_{12} \\
%x_1 x_6 x_8 x_{10} \\
%x_2 x_4 x_9 x_{11} \\
%x_3 x_5 x_7 x_{12} \\
%x_1 x_5 x_9 x_{10} \\
%x_2 x_6 x_7 x_{11} \\
%x_3 x_4 x_8 x_{12} \\
%$
%\begin{figure}[!htbp]
% \input{fig/symmetry_example}
% \caption{Example of symmetries}
%\end{figure}


%The symmetric group of permutations of $\Vars$ (i.e. bijections from $\Vars$ to $\Vars$) is noted
%$\Group(\Vars)$. The group $\Group(\Vars)$ naturally acts on the set of literals: for $g
%\in \Group(\Vars)$ and a literal $\ell \in \Lits $, $g.\ell = g(\ell)$ if $\ell$ is a
%positive literal, $g.\ell = \neg g(\neg \ell)$ if $\ell$ is a negative literal.
%The group $\Group(\Vars)$ also acts on (partial) assignments of $\Vars$ as follows: for
%$g \in \Group(\Vars)$, $\alpha \in \Assignments(\Vars)$, $g.\alpha = \{ g.\ell ~|~ \ell \in \alpha \}$. Let $\varphi$ be a formula, and $g \in \Group(\Vars)$.
% We say that $g\in \Group(\Vars)$ is a
%symmetry of $ \varphi$ if for every \emph{complete} assignment $\alpha$:
%The set of symmetries of $\varphi$ is noted $S(\varphi) \subseteq \Group(\Vars)$.
%
%$\alpha \models \varphi \leftrightarrow g.\alpha. \models \varphi$ for $g \in S(\varphi)$.
%The group $S(\varphi)$ also acts on (partial) assignments of $\Vars$ as follows: for
%$g \in S(\varphi)$, $\alpha \in \Assignments(\Vars)$, $g.\alpha = \{ g.\ell ~|~ \ell \in \alpha \}$,
%and acts also on clauses as follow g.$\omega$ = $\{g.l ~|~ l \in \omega \}$.
%
%
%The next section presents how to compute the set of \emph{generators} of a given formula.
\section{Symmetry detection in SAT}
For the detection of symmetries in SAT, we fist introduce the graph automorphism notion.
Given a colored graph $G = (V, E, \gamma)$, with vertex set $V \in  [1, n] $, edge set E and
$\gamma$ a function that apply a mapping : $V \rightarrow C$ where C is a set of \emph{colors}.
An automorphism of G is a permutation from its vertices $g :V \rightarrow V$ 
such that:
\begin{itemize}
 \item $\forall (u, v) \in E \implies (g.u, g.v) \in E$
 \item $\forall v \in V, \gamma(v) = \gamma(g.v)$
\end{itemize}
The graph automorphism problem is to find if a given graph has a non-trivial permutation group. 
The computational complexity of this algorithm is conjectured to be strictly between P and NP.
Several tools exist to tackle this problem like \saucy~\cite{katebi2010symmetry},
\bliss~\cite{JunttilaKaski:ALENEX2007}, \nauty~\cite{mckay2003nauty}, etc.

There exists different ways to encode a SAT problem,
which leads to different symmetries in these problems.
When a symmetry depends on the structure of the problem, we say \emph{syntactic} symmetries. 
In contrast, symmetries were \emph{semantic}, when it is not inherent to the encoding.
To find symmetries in SAT problem, the formula is transformed into colored graphs
and an automorphism tool is applied onto. Specifically, given a formula $\varphi$ with
$m$ clauses over $n$ variables, the graph is constructed as follows~\cite{biere2009handbook}:
\begin{itemize}
 \item \emph{clause nodes}: represent each of the $m$ clauses by a node with color 0;
 \item \emph{literal nodes}: represent each of the $l$ literals by a node with color 1;
 \item \emph{clauses edges}: connect a clause to its literal by linking the corresponding  clause node and literal nodes;
 \item \emph{boolean consistency edges}: connect each pair of literals that correspond to the same variables.
\end{itemize}

\begin{figure}[h!]
 \begin{minipage}[c]{.2\textwidth}
  $\omega_{1} = \{ x_{1}, x_{2}, x_{3} \}$ \\
  $\omega_{2} = \{ x_{4}, x_{5}, x_{6} \}$ \\
  $\omega_{3} = \{ x_{1}, x_{4} \}$ \\
  $\omega_{4} = \{ x_{2}, x_{5} \}$ \\
  $\omega_{5} = \{ x_{3}, x_{6} \}$ \\
  $\omega_{6} = \{ \neg x_{1}, \neg x_{2} \}$ \\
  $\omega_{7} = \{ \neg x_{1}, \neg x_{3} \}$ \\
  $\omega_{8} = \{ \neg x_{2}, \neg x_{3} \}$ \\
  $\omega_{9} = \{ \neg x_{4}, \neg x_{5} \}$ \\
  $\omega_{10} = \{ \neg x_{4}, \neg x_{6} \}$ \\
  $\omega_{11} = \{ \neg x_{5}, \neg x_{6} \}$ \\
  
 \end{minipage}
 \begin{minipage}[l]{.75\textwidth}
  \includegraphics[width=4.3in]{cnfs/graph_cnf_no_opt-crop}
 \end{minipage}
 \caption{Example of constructed symmetry graph for a given CNF}
 \label{fig:graph_no_opt}
\end{figure}

\Cref{fig:graph_no_opt} shows the graph representation of a CNF. This problem has 6 variables and 11
clauses. So, the graph will have  12  + 11 = 33 vertexes where 12 represents literal vertexes (circle in the figure ) 
and 11 represents the number of clause vertexes (square in the figure). The graph will also have 6 + 24 = 30 edges, 6 for Boolean consistency 
(red color in the figure) and 24 edges that rely clause vertexes to the literals.

% and  24 + 36 = 60 
%
%\hakan{Explication du graph + informations num nodes num edges. Probleme reel battleship
%}
%
%The battleship problems place one  ship of size *** and two ships of size* in grid 3x4 \\
%1  2  3\\
%4  5  6\\
%7  8  9\\
%10 11 12\\
%
%one ship per row.\\
%
%Produced graph contains and = 60 edges 

An optimization of this graph is possible with the usage of binary clauses i.e. a clause with only two literals.
The clause node can be omitted and we connect the two literals. As we cannot distinguish between the optimized edge 
and Boolean consistency edges, we must check if the produced permutations are spurious. 
To do so, as we ensure the permutation commutes with the negation it suffices to check:
$$\forall x \in \support(g), g.\neg x = \neg g.x$$

Roughly speaking, we check if the image of the negation of $x$ is equals to the negation of the image of $x$,
for each element $x$ in the support of the permutation.
This optimization allows to compute symmetries of the problem more efficiently.
In the previous example, the graph has deleted 12 nodes and 12 edges. More generally,
the graph removes as many nodes and edges as binary clauses on the formula.
\Cref{fig:graph_opt} represents the optimized version the graph.
\begin{figure}[!htbp]
 \begin{minipage}[r]{.2\textwidth}
   $\omega_{1} = \{ x_{1}, x_{2}, x_{3} \}$ \\
 $\omega_{2} = \{ x_{4}, x_{5}, x_{6} \}$ \\
 $\omega_{3} = \{ x_{1}, x_{4} \}$ \\
 $\omega_{4} = \{ x_{2}, x_{5} \}$ \\
 $\omega_{5} = \{ x_{3}, x_{6} \}$ \\
 $\omega_{6} = \{ \neg x_{1}, \neg x_{2} \}$ \\
 $\omega_{7} = \{ \neg x_{1}, \neg x_{3} \}$ \\
 $\omega_{8} = \{ \neg x_{2}, \neg x_{3} \}$ \\
 $\omega_{9} = \{ \neg x_{4}, \neg x_{5} \}$ \\
 $\omega_{10} = \{ \neg x_{4}, \neg x_{6} \}$ \\
 $\omega_{11} = \{ \neg x_{5}, \neg x_{6} \}$ \\
 \end{minipage}
 \begin{minipage}[r]{.75\textwidth}
  \includegraphics[width=4.3in]{cnfs/graph_cnf_opt-crop}
 \end{minipage}
 \caption{Example of constructed symmetry graph for a given CNF}
  \label{fig:graph_opt}
\end{figure}


After the construction of a such graph, a graph automorphism tools take it as input and give
the set of generators as output.With the previous graph, the following generators are obtained:


\begin{center}
 \begin{minipage}[c]{.635\textwidth}
  $g_1 = (x_2 \enskip x_3)(x_5 \enskip x_6)(\neg x_2 \enskip \neg x_3)(\neg x_5 \enskip \neg x_6)$\\
  $g_2 = (x_1 \enskip x_2)(x_4 \enskip x_5)(\neg x_1 \enskip \neg x_2)(\neg x_4 \enskip \neg x_5)$\\
  $g_3 = (x_1 \enskip x_4)(x_2 \enskip x_5)(x_3 \enskip x_6)(\neg x_1 \enskip \neg x_4)(\neg x_2 \enskip \neg x_5)(\neg x_3 \enskip \neg x_6)$
 \end{minipage}
\end{center}

These permutations form a permutation group and so induce an equivalence relation.
\Cref{fig:orbit} shows graphical representation of an orbit, where each node represents a literal.
Two literals are linked with an arc if it exists a permutation that maps one to the other. 
An orbit must be a \emph{strongly connected component} (SCC).  
Some permutations have a special form like two-dimensional
array as in this example.
 A further section (\ref{sec:matrix-sbp}) shows how to exploit this special form.
\begin{figure}[!htbp]
 \input{fig/exemple-orbits}
 \caption{Graphical representation of an orbit}
 \label{fig:orbit}
\end{figure}

\section{Usage of symmetries}
\emph{Symmetry breaking} aims at eliminating symmetry, either
by \emph{statically} posting symmetry breaking constraints that invalidate symmetric
assignments, or by altering the search space \emph{dynamically} to avoid symmetric search paths.

\subsection{Static symmetry breaking}

Generally symmetry breaking allows SAT solver to avoid visit isomorphic search space.
Visiting one branch is equivalent to visit each symmetric branch and so visiting this one is sufficient to 
determine satisfiability of the whole formula. Symmetrical branch are discarded by the solver with the addition of 
constraints. These constraint are not satisfied if the solver visit equivalent assignment.
In other words, when symmetries of a problems are ignored, solver visit a branch multiple times.
Suppose the \textit{pigeonhole problems} (See \cref{fig:hole}), where $n$ pigeons are put into $n-1$
holes, with the constraint that each pigeon must be in a different hole is a
highly symmetric problem. Indeed, all the pigeons (resp. holes) are exchangeable
without changing the initial problem. Trying to solve it with a standard SAT
solver, like MiniSAT~\cite{een2003extensible}, turns out to be very time
consuming (and even impossible, in reasonable time, for high values of $n$).
Here, such a standard solver ignores the symmetry property of the problem, and
then potentially tries all variables combinations ; this eventually leads to
a combinatorial explosion.


\begin{figure}
	\centering
	\begin{tikzpicture}[
	start chain = going right,
	node distance = 0pt,
	AStyle/.style={draw, minimum width=2em, minimum height=2em, 
		outer sep=0pt, on chain, fill=yellow!0!white}]
	\node [AStyle] (1) {\huge\textcolor{gray}{\PHdove}};
	\node [AStyle] (4) {\huge\textcolor{gray}{\PHdove}};
	\node [AStyle] (5) {\huge\textcolor{gray}{\PHdove}};
	\node [AStyle, draw] (6) {\huge\textcolor{gray}{\PHdove}};
	\node [ minimum width=2em, minimum height=2em, 
	outer sep=1pt, on chain] (7) {\huge\textcolor{gray}{\PHdove}};
	\end{tikzpicture}
	\caption{Graphical representation of pigeonhole problem}
	\label{fig:hole}
\end{figure}


This section explains how to exploit statically symmetrical properties of a SAT problem. This can be summarize with the following two 
questions: 1) How  to choose branch that are equivalent to all symmetric ones?
 2) How to generate constraints that forbid symmetrical assignments?




To answer the first part of the problematic: how to choose branch that are equivalent to all symmetric ones ?
We need to introduce an ordering relation between assignments

\begin{definition}[Assignments ordering]
 \label{def:assignment_ordering}
 We assume a total order, $\prec$, on $\Vars$.  Given two assignments $(\alpha,\beta) \in \Assignments(\Vars)^2 $, 
 we say that $\alpha$ is strictly smaller than $\beta$, noted $\alpha < \beta$, if there exists a variable $v \in \Vars$
 such that:
 \begin{itemize}
  \item for all $v' \prec v$, either $v' \in \alpha \cap \beta$ or $\neg v' \in \alpha \cap
  \beta$.
  \item $\neg v \in \alpha$ and $v \in \beta$ \footnote{We could have chosen as well 
   $v \in \alpha$ and $\neg v \in \beta$ without loss of generality.}.
 \end{itemize}
\end{definition}

In other words, the prefix of both assignment is equal according to the ordering relation~$\prec$
and the next variable $v$ has a different value, $\alpha(v) = \false, \beta(v) = \true$, then $\alpha < \beta$.
Note that $<$ coincides with the lexicographical order on \emph{complete}
assignments. 
Furthermore, the $<$ relation is monotonic as expressed in the following proposition:
\begin{proposition}[Monotonicity of assignments ordering]
 \label{prop:monocity_assignments_ordering}
 Let  $(\alpha,\alpha',\beta,\beta') \in \Assignments(\Vars)^4 $ be four assignments.
 $$\text{If}~\alpha \subseteq \alpha'~\text{and}~\beta \subseteq \beta',~\text{then}~\alpha < \beta \implies \alpha' < \beta'$$
\end{proposition}
\begin{proof}
 The proposition follows on directly from definition \ref{def:assignment_ordering}.
\end{proof}

Given a formula $\varphi$ and its group of symmetry $G$,
the \emph{orbit of $\alpha$ under $G$} (or
simply the \emph{orbit of $\alpha$} when $G$ is clear from the context) is the set
$ [\alpha]_G=\{ g.\alpha \mid g \in G \}$. 
The lexicographic leader (\textit{lex-leader} for short) of an orbit $[\alpha]_G$ is defined by
$min_<([\alpha]_G)$. This \textit{lex-leader} is unique because the lexicographic
order is a total order.
The optimal approach to solve a symmetric SAT problem would be to explore
only one assignment per orbit (for instance each lex-leader). \Cref{fig:lex-leader} shows different orbits, each dot in an orbit (ellipse in the figure) is an assignment, and the lex-leader is the empty red one.
To avoid exploring 
symmetry search space, \emph{symmetry breaking predicates} (SBP) also called \emph{lex-leader constraints} 
are added to the formula.
These constraints are only true for the \emph{lex-leader} \cite{crawford1996symmetry} and prevent other assignments from being explored. 
\begin{figure}[!htbp]
 \centering
 % \includegraphics[width=2in]{fig/assignment-lex-leader}
 \input{fig/assignment-lex-leader}
 \caption{Show lex-leader per orbit}
 \label{fig:lex-leader}
\end{figure}

Lex-leader predicates for a permutation $g \in G_\varphi$ is defined as :
$$LL_g = \forall i : (\forall j < i : x_j = g.x_j) \Rightarrow  x_i \preceq g.x_i$$
In other words, each assignment whose have a variable such that its image under $g$ is smaller according to the ordering relation $\prec$, is pruned by $LL_g$.
Conjunction of $LL_g$, for all permutations  $g \in G_{\varphi} $ results a sound and complete symmetry breaking predicates also called \emph{full symmetry breaking}. Only lex-leader assignment will be visited 
per orbit. Hence, finding the lex-leader of an orbit is computationally hard~\cite{Luks2004}. 
Conjunction of $LL_g$ for some $G \subset G_{\varphi}$ results a symmetry breaking predicates that aims to
visit at least one assignment per orbit and called is \emph{partial symmetry breaking}.
In both cases, the set of symmetry breaking predicates generated is denoted as $\psi$.
Since  a group may have a exponential number of permutations, all symmetry breaking predicates belongs
to the group must be generated to ensure full symmetry breaking. These constraints will overload the 
solver and slow down its core principle (unit propagation). Hence, slow down overall time computation.
Conversely, partial symmetry breaking adds few constraints and bring often considerable reduction of the
search space. Generally, the set of generators produced by automorphism tool is chosen as a subgroup.
Partial symmetry breaking gives a good trade off between the number of generated constraints and reduction of the search space.

%
%To ensure the visiting only the lex leader, all SBPs of all permutations 
%belongs to the group must be generated.
%Adding too many SBPs clauses will overload the solver and slow down the unit propagation.
%
%When only one assignment per orbit (generally the lex-leader) is visited, this is called  \emph{full symmetry breaking}.
%Conversely, \emph{partial symmetry breaking} aims to visit at least one assignment per orbit.
%Only some of the permutations are used to generate SBPS, that are generally  the set of generators 
%given by the automorphism tool.
%This approach is more easy to set up and bring considerable reduction of the search spaces.
%in some $G \subseteq G_{\varphi} $ results a sound and complete symmetry breaking predicates
%but not necessarily \emph{complete} symmetry breaking predicates for $G_{\varphi}$ noted $\psi$.

\begin{theorem}[Satisfiability preservation SBPs]
 \label{theorem:satisfiability_preservation_SBPs}
 Let $\varphi$ be a formula and $\psi$ the computed \textit{SBPs} for the set of symmetries in $G_{\varphi}$:
 
 $$\varphi~and ~\varphi \wedge \psi \text{ are equi-satisfiable}.$$
\end{theorem}
\begin{proof}
 If $\varphi \wedge \psi$ is SAT then $\varphi$ is trivially SAT. If
 $\varphi$ is SAT, then there is some assignment $\beta$ that satisfies $\varphi$.
 Without loss of generality, $\beta$ can be chosen to be the lex-leader of its
 orbit under $G_{\varphi}$. Thus, $g$ does not contradict $\beta$, which implies that
 $\beta \models \psi$.
\end{proof}


% By definition of an orbit, it exists a permutation that map each assignment to another in the same orbit. 

%
%Lex-leader constraints are build for each permutation in the group.
%Given a permutation 
%Generation of these lex-leaders constraints proposed by Crawford et al.~\cite{crawford1996symmetry}:
%
%$$\forall i : (\forall j < i : x_j = g.x_j) \Rightarrow  x_i \preceq g.x_i$$
%
%In other words, assuming the ordering relation depicted in \Cref{def:assignment_ordering}, for one permutation,
%these constraint express that the value of the variable $x_i$ must be smaller or equal than the
%value of $g.x_i$ and all variables $x_j$ that respect the constraint $x_j \prec x_i$,  
%must have the same value of its symmetric. As such, these constraints encodes a valid 
%lex leader with respect to this permutation.

Generation of lex-leader constraints proposed by Crawford et al.~\cite{crawford1996symmetry} is defined as follows:
$$ LL_g = \forall i : (\forall j < i : x_j = g.x_j) \Rightarrow  \neg x_i \lor g.x_i$$
 
 \Cref{fig:esbp_gen} shows an example of generated clauses for the  permutation $g_3$ of the previous 
 example and a lexicographic order. Last constraint present in the figure produce tautological clause,
 effectively variable $x_1$ or $x_4$ are present in both polarity. The constraints of other variables produce 
 also tautological clauses. 
 
 
 \begin{figure}[!htbp]
  \input{fig/example-sbp}
  \caption{Example of generated SBPs for one permutation}
  \label{fig:esbp_gen}
 \end{figure}
 
 
 Moreover, the number of clauses generated per constraint increase exponentially with the number of variable present in the permutation.
  Hence, Aloul et al~\cite{aloul06} propose a more compact representation of  symmetry breaking predicates.
 
 Let $g$ a permutation, let $\support_g$ = $\{x_1, \cdots, x_n\}$ the support of the permutation $g$ be ordered 
 such that $x_i \preceq x_j$ iff $i \leq j$  and let $\{y_0,\cdots, y_{n} \}$ be a set of auxiliary variables
 disjoint from $\support_g$. These auxiliary variables encode equality of literals in such $y_0$ is set as an unit clause
 and encodes the first equality.
 Following clauses encode a compact lex-leader for a permutation:
 
\begin{center}
\begin{tabular}{cc|cc}
 $\neg y_i \lor \neg x_{i-1} \lor \neg x_i \lor g.x_i$ & $1 \leq i \leq n$ & $ \neg y_i \lor \neg x_{i-1} \lor \neg y_{i+1}$ & $1 \leq i \leq n$ \\
 $\neg y_i \lor  g.x_{i-1} \lor \neg x_i \lor g.x_i$ & $1 \leq i \leq n$ & $ \neg y_i \lor g.x_{i-1} \lor \neg y_{i+1}$ & $1 \leq i \leq n$ \\
 
\end{tabular}
\end{center}

\Cref{fig:esbp_compact_gen} shows the compact encoding of generated clauses. This form grows linearly with the number of variables.
Auxiliary variable encodes the equality of two literals allows to achieve this reduction. Three auxiliary variables are introduced
in this example $x_7, x_8, x_9$ such that $x_7$ encode the equality of $x_1$ and $x_4$, $x_8$ equality of $x_2$ and $x_5$, and $x_9$ equality of $x_3$ and $x_6$.

 \begin{figure}[!htbp]
 \input{fig/example-compact-sbp}
 \caption{Example of compact generated SBPs for one permutation}
 \label{fig:esbp_compact_gen}
\end{figure}

\shatter~\cite{aloul06} is a tool fot partial symmetry breaking that computes symmetry with $\saucy$ automorphism tool and generate a new formula with compact lex-leader encoding. It uses only generators given by the automorphism tool. Following table shows the number of symmetry breaking predicates clauses and the
number of auxiliary variables added to the original formula.

\input{sbp-table}

%\hakan{mettre tableauw nombre de SBP generÃ©}
%
%\begin{figure}[!htbp]
% \centering
% \includegraphics[height=5cm]{example-image-a}
% \label{}
%\end{figure}

An improvement of static symmetry breaking was made by Devriendt et al~\cite{devriendt2016improved} with a tool 
called $\breakid$. It exploits some properties from the structure of generators. On some circumstance 
a linear number of constraints can break all group. The other tries to add a maximum of binary clauses that 
is useful because it can participate often to unit propagation and so to the conflict analysis.

\subsubsection{Special form of the group} \label{sec:matrix-sbp}
Some formula presents a specific type of symmetry called \emph{row (column) interchangeability}, when a
subset of variables is structured as a two-dimensional matrix. Each row (column) is interchangeable
with the symmetries. 
This form of symmetry is common in different kind of problem like pigeon hole problems in which
pigeons and holes are interchangeable or in the delivery system in which trucks of a fleet are interchangeable.
Usage of row (column) interchangeability can significantly improve SAT performance. 
Effectively symmetries can be eliminated by the addition 
of only a linear number of symmetry-breaking constraints~\cite{flener2002breaking}. 
One condition must be satisfied to ensure this linear number of constraints:
lexicographic order needs to respect the structure of the matrix.
In practice, automorphism tools give only the set generators which contains no information on
the structure of the group. 
Authors of $\breakid$~\cite{devriendt2016improved} develop an algorithm to detect this specific 
structure and exploit it.

\subsubsection{Binary lex-leader constraints}
$\breakid$ has another approach that aims to post many lex-leader constraints.
The first constraint of symmetry breaking predicates must produce a binary clause.
Building many binary clauses is possible without enumerating the whole symmetry group. 
It suffices to compute the orbit of the smallest variable according to the ordering relation. As the orbit can be seen as a strong connected component, it must exist a permutation that permutes the smallest variable with all other variables in the same orbit.
Then, as many binary clauses as variables (without the smallest variable) in the orbit can be added to the formula. Constructing a sequence of subgroups that stabilize the smallest variable (i.e. not have the smallest variable in its support) results to new binary clauses.
This sequence ends when trivial subgroup is reached and is called a  \emph{stabilizer chain}.

\Cref{fig:binary_sbp} shows application of the generation of binary clauses.
In the example, considered group has three permutations and its graphical representation
is showing. Given the lexicographic order, the smallest variable is $x_1$ and 
all other variables are in its orbits. According to the ordering relation, five 
symmetry breaking predicates are generated with the formula $\neg x_1 \lor g.x_1$.
Then, subgroup that stabilizes $x_1$ is computed and it remains only one permutation $g_2$.
As it smallest variable is $x_2$, the constraint $\neg x_2 \lor x_3$ is generated.
Stabilizer chain leads to trivial group and no more binary clauses are generated.
In total, six binary clauses is generated without adding any auxiliary variables.
Moreover, a property can be observed, when the smallest variable have the greatest value 
(\true in this case), all variables in the orbits must have the same value.
 \begin{figure}[!htbp]
 \input{fig/binary-sbp}
 \caption{Generation of binary symmetry breaking predicates}
 \label{fig:binary_sbp}
\end{figure}

The size of the stabilizer chain is heavily dependent of the chose lexicographic order.
More stabilizer discard permutations and more trivial subgroup is reached quickly and fewer 
binary clauses are generated. An incremental order is proposed to optimize the number of generates binary clauses. First, orbit of all variables is computed and the variable with fewest number of occurrence is choosing among the biggest orbit. The idea is that biggest orbit produces more
clauses and the variable appearing in few permutations reduce the number of stabilized permutations. This procedure is applied until trivial group is reached. At the end, remaining variables are added to the order.


\subsubsection{BreakID}


As summary, $\breakid$ combines three idea. First it searches if produced generators by the automorphism tool has the special
form row interchangeability and if that is the case exploit it. This first point establish a prefix of an order for the lex-leader.
Secondly this order will be completed to generate a maximum number of binary lex-leader constraints. Thirdly, the order is supplemented with leftover variables until it is total and classical lex-leader constraints are added to the original formula. 
%\subsection{Evaluation of performance}
%\hakan{Compare BreakID et shatter perfs on instances}



%The exploitation of symmetries statically is called \emph{static symmetry breaking}.
%It acts like a preprocessor which add \emph{symmetry breaking predicates} (SBPs) at the 
%original formula and solve the augmented problem. 
%This approach gives good performances in practice.
%
%\hakan{Conclu static}


\subsubsection{Conclusion}
Static symmetry breaking acts as a preprocessor that augment the initial formula with
symmetry breaking predicates. These constraints avoid exploration of symmetric search space.
In the general case, the number of these clauses is often too large to be
effectively handled by a SAT solver~\cite{Luks2004}. 
On the other hand, if only a subset of the symmetries is considered then the resulting search pruning
will not be perfect and its effectiveness depends heavily on the
heuristically chosen symmetries \cite{biere2009handbook}.
An extremely important point for static symmetry breaking is the chosen lexicographic order.
Variable ordering may impact the number of generated constraints and so the performance of
the underlying SAT solver. Different orders are studied in the literature. 
One of the simplest orders was the sorted variables according to their numbers.
Some other order exists and exploit structural properties of the 
problem. 
Some recent works brings some optimizations and solves more instances.
Despite these optimizations and the good reduction of the search space with symmetries,
some formula that exhibit symmetries still intractable for a state-of-the-art SAT solver.
Moreover, a disadvantage of static symmetry breaking is that the solver is influenced by SBPs
and explore the search space with a different manner and can affect performance negatively.


%\begin{figure}[!htbp]
% \input{fig/big-picture-static}
% \caption{Caption}
% \label{fig:big_picture_static}
%\end{figure}


\subsection{Dynamic symmetry breaking}


Dynamic symmetry breaking approaches aims to exploits symmetries during the solving by altering search space dynamically.
This is possible with the integration of symmetry breaking approach inside existing SAT solver. It uses symmetries presents 
in the formula to propagate symmetrical literals.
As consequence, the solver reduces the number of decisions, that are chosen heuristically and increase the number of propagation
that are consequence of the formula. In other words, symmetries allows to transform some "guesses" as "deductions".
And so, improves performance of the underlying SAT solver.
In the literature, different approaches of dynamic symmetry breaking, this section presents some of them.


\subsubsection{SymChaff}
One of the first dynamic symmetry breaking approaches is \emph{SymChaff}~\cite{sabharwal2005symchaff}
and is applicable only on special groups where all couple of variables are symmetric \cref{sec:matrix-sbp}.
The idea of this approach is to treat each orbit like a \emph{symbolic variable}, i.e. instead of considering a single
variable (branching), all symmetric variables are considered at the same time and so backtracked at the same time 
(k-branching).
In this special case of groups, the number of orbits is easy to compute but the order in which they would be
applied has a tremendous impact of the solver performance.
In the general case, when we take any groups computing the number of orbits will be very difficult and this approach
will be intractable.

\subsubsection{Symmetry Propagation}
A different approach can be used to reduce search space using symmetries is \emph{symmetry propagation}~\cite{Devriendt12}.
The general idea of this approach is to propagate symmetrical literals of those already propagated.
In other words, it accelerates the tree traversal by ``transforming some guessing (decisions) to deductions (propagation)''.
Indeed, problem that presents symmetries makes possible to deduce some value 
for the variables that would be guessed if symmetry properties were ignored.
These deductions will reduce the overall tree traversal depth and hence eventually accelerate the solving process.
To explain this approach, some definitions are required.

\begin{definition}[Logical consequence]
 \label{def:logical_consequence}
 A formula $\phi$ is a logical consequence of a formula $\varphi$ denoted by $\varphi \models \phi$ if for all assignment
 $\alpha$ satisfying $\varphi$, it also satisfies $\phi$. Two formulas are \emph{logically equivalent} if each is a logical
 consequence of the other.
\end{definition}
\begin{proposition}[Symmetry propagation]
 \label{prop:symmetry_propagation}
 Let $\varphi$ be a formula, $\alpha$ an assignment and $l$ a literal. 
 If $g$ is a symmetry (permutation) of $\varphi \cup \alpha$ and
 $\varphi \models \{l\}$, then $\varphi \cup \alpha \models g.\{l\}$ is also true.
\end{proposition}
In other words, if a literal $l$ was propagated by the solver and $g$ is a \emph{valid} symmetry for the
sub problem $\varphi \cup \alpha$ (in which all satisfied clauses and false literals are removed), so , the solver can
also propagate the symmetrical of $l$. The problem here is to determinate which symmetries are valid for the formula
$\varphi \cup \alpha$.
\begin{definition}[Active symmetry]
 \label{def:active_symmetry}
 A symmetry $g$ is called active under a partial assignment $\alpha$ $\text{if } g.\alpha = \alpha$
\end{definition}
The definition~\ref{def:active_symmetry} leads to the following proposition:
\begin{proposition}
 \label{prop:active_symmetry}
 Let $\varphi$ a formula and $\alpha$ a partial assignment. Let $g$ a symmetry of $\varphi$,
 if $g$ is active under the assignment $\alpha$, then $g$ is also a symmetry of $\varphi \cup \alpha$
\end{proposition}
The previous proposition states that an active symmetry $g$ for a partial assignment $\alpha$ still valid for
the formula $\varphi \cup \alpha$. So when a literal $l$ is propagated, and a symmetry $g$ is active for a
partial assignment $\alpha$, the solver can also propagate $g.l$. 
Moreover, the group theory allows to compose permutations with the composition operator~$\circ$ and the composition of two active symmetries is also an active symmetry so the solver can also propagate. $g^2.l, g^3.l, ... $

Devriendt et al improves the active symmetries in the SAT context, introducing \emph{weakly active} symmetries.
\begin{definition}[Weakly active symmetry]
 \label{def:weakly_active_symmetry}
 Let $\varphi$ a formula and ($\delta, \alpha, \gamma$) a state of a CDCL solver in which $\delta$ is the set of decisions
 $\alpha$ is the current assignment and $\gamma$ the reasons of the learned clauses. Then a symmetry $g$ is weakly active 
 if $g.\delta \subseteq \alpha$
\end{definition}
This definition leads to the following proposition:
\begin{proposition}
 Let $\varphi$ be a formula, $\alpha $ an assignment. If
 there exists a subset $\delta \subseteq \alpha $ and a symmetry $g$ of $\varphi$ such that 
 $g.\delta \subseteq \alpha $ and $\varphi \cup \delta \models \varphi \cup \alpha$, then $g$ 
 also is a symmetry of $\varphi \cup \alpha $.
\end{proposition}


In other words, we can detect with a minimal effort, the symmetries of $\varphi
\cup \alpha$ by keeping track of the set of variables $\delta$, which are 
in a state-of-the-art complete SAT solving algorithms, the set of decision variables.
Obviously, a weakly active symmetry can also propagate the symmetrical literals of a propagated one.
Moreover, weakly active symmetries allow more propagation and so is more efficient.
Note that if a weakly active symmetry wants to propagate a symmetrical literal which are already affected to the 
opposite value, this leads to a symmetry conflict and the solver backtrack to propagate the symmetrical value correctly.

%\hakan{Mettre des tableaux, courbes etc ...}\\
%\hakan{Courbe VS static an no sbp}\\
%\hakan{Conclu SP, depend on the solver choice}\\

Symmetry propagation gives good performances on many symmetric instances.
The overall performance of the symmetry propagation is intrinsically related to the decision heuristics of the underlying SAT solver.

Note that, this approach don't discard any assignments like in the static approach where 
not lex-leader assignment were eliminated by symmetry breaking predicates.

%One optimization of symmetry propagation is the following proposition, as seen in 
% each propagated clause has a reason which is an assertive clause.
%If the symmetrical clause is also an assertive one, this clause can be added in the formula without any requirements
%(even if the permutation is not weakly active). The added symmetrical clause will also participate to unit propagation and propagate the symmetrical literal.

\subsubsection{Symmetry Explanation Learning}


Another approach to exploit symmetry without removing any satisfiable assignment of the problem
is \emph{Symmetry Explanation Learning}~\cite{devriendt2017symmetric} (SEL). 
Symmetries of a formula leaves this one invariant. Moreover all learned clauses are logical consequence of the problem, symmetric of these clauses are also valid.
Unlike Symmetry explanation scheme~\cite{benhamou2010enhancing} (SLS) where all symmetrical learned clauses
are added to the clause database.
The idea of this approach is to learn useful symmetrical variant of learned clauses.
 A clause is said useful if it participates to the unit propagation or conflict analysis.
Computing all symmetrical learn clauses will create a huge overhead and will be intractable 
on real problems.
% As symmetries leave the formula, the symmetrical clauses can be already
%in managed clause by the solver and make unit propagation heavier.

Symmetry Explanation Learning uses the following fact:
on the unit propagation, propagated literals has a reason clause which is assertive.
Generally , symmetries permute only few literals in a clause and so symmetrical clauses may
also be assertive and participate to unit propagation.
 These clauses are stored in different learning scheme and 
treated separately. Solver promotes these clause  uniquely where they are effectively useful
at the end of unit propagation. As unit propagation is done until fix point, it
ensures that no duplicate clause is added in the problem.
To limit memory impact, symmetrical clauses are removed when the propagated literal 
responsible of the computation is unaffected.

SEL provides some interesting properties. First, the authors proves that its propagation are a super-set of the one provided by symmetry propagation. It also no need to track any status of 
symmetries as opposed to symmetry propagation. Like symmetry propagation no satisfying assignment are discarded.
As disadvantage, SEL may flood the solver if the used set of symmetries is big and take time 
to compute symmetrical clauses. 


\subsection{Conclusion}


%SAT solvers are fine tuned algorithm to solve propositional formula, adding additional component that modify 
%fundamentally the behavior of a SAT solver may impact negatively this performance.

%\hakan{Perf of differents approaches}

%\begin{proposition}[Satisfiability preservation] 
%% mode: flyspell
%% coding: utf-8
%% End: